services:
  # Backend API
  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    container_name: port-backend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: 5001
      MONGODB_URI: ${MONGODB_URI:-mongodb://admin:dbmjXsNq@host.docker.internal:27017/?authSource=admin}
      JWT_SECRET: ${JWT_SECRET}
      DC_POWER_FLOW_API: ${DC_POWER_FLOW_API:-http://dc-power-flow:5002}
      VESSEL_API: ${VESSEL_API:-http://vessel-modelling:5003}
      VESSEL_API_URL: ${VESSEL_API:-http://vessel-modelling:5003}
      FRONTEND_URL: ${FRONTEND_URL}
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASS: ${SMTP_PASS}
    networks:
      - port-network
    ports:
      - "127.0.0.1:5001:5001"
    volumes:
      - ./backend/logs:/app/logs
    extra_hosts:
      - "host.docker.internal:host-gateway"

  # DC Power Flow Service
  dc-power-flow:
    build:
      context: ./dc_power_flow
      dockerfile: Dockerfile
    container_name: port-dc-power-flow
    restart: unless-stopped
    environment:
      FLASK_ENV: production
      PORT: 5002
    networks:
      - port-network
    ports:
      - "127.0.0.1:5002:5002"
    volumes:
      - ./dc_power_flow/data:/app/data
      - ./dc_power_flow/logs:/app/logs
      # Mount source code for development (optional)
      - ./dc_power_flow/main.py:/app/main.py
      - ./dc_power_flow/api_server.py:/app/api_server.py
      - ./dc_power_flow/run_simulation.sh:/app/run_simulation.sh

  # Vessel Modelling Service
  vessel-modelling:
    build:
      context: ./vessel_modelling
      dockerfile: Dockerfile
    container_name: port-vessel-modelling
    restart: unless-stopped
    environment:
      FLASK_ENV: production
      PORT: 5003
    networks:
      - port-network
    ports:
      - "127.0.0.1:5003:5003"
    volumes:
      - ./vessel_modelling/data:/app/data
      - ./vessel_modelling/logs:/app/logs
      - ./vessel_modelling/output:/app/output

  # Daily automation to run vessel_automation.py at 02:00
  vessel-automation:
    build:
      context: ./vessel_modelling
      dockerfile: Dockerfile.automation
    container_name: port-vessel-automation
    environment:
      API_BASE_URL: ${VESSEL_API:-http://vessel-modelling:5003}
      TZ: ${TZ:-UTC}
    depends_on:
      - vessel-modelling
    networks:
      - port-network
    restart: unless-stopped
    volumes:
      - ./vessel_modelling/logs:/app/logs
      - ./vessel_modelling/output:/app/output

  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_BACKEND_URL: ${NEXT_PUBLIC_BACKEND_URL}
    container_name: port-frontend
    restart: unless-stopped
    environment:
      NODE_ENV: production
      NEXT_PUBLIC_BACKEND_URL: ${NEXT_PUBLIC_BACKEND_URL}
    depends_on:
      - backend
      - dc-power-flow
      - vessel-modelling
    networks:
      - port-network
    ports:
      - "127.0.0.1:3000:3000"

  # Nginx reverse proxy
  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/letsencrypt:ro
      - ./nginx/logs:/var/log/nginx
      - certbot-webroot:/var/www/certbot:ro
    networks:
      - port-network
    depends_on:
      - frontend
      - backend
      - dc-power-flow
      - vessel-modelling
    restart: unless-stopped

  # Certbot for SSL certificates (production)
  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - ./nginx/ssl:/etc/letsencrypt
      - certbot-webroot:/var/www/certbot
    command: certonly --webroot --webroot-path=/var/www/certbot --email diogo.paulino10@gmail.com --agree-tos --no-eff-email -d portdt.prsma.com
    profiles:
      - ssl-setup

volumes:
  certbot-webroot:

networks:
  port-network:
    driver: bridge 
